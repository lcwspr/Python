# 典型案例


# 块作用域？
if True:
    i = 1
    print(i)   # 1


# 函数作用域
def f():
    i = 1
# f(i)     # 报错


# 静态作用域
i = 1
def test():
    global i
    i += 1
test()


# 静态作用域
i = 1
def g():
    print(i)

def f():
    i = 2
    g()
f()  # 1


# 闭包、全局作用域

i = 1
def f():
    i = 2
    def g():
        print(i)
    return g

func = f()
func()
print(i)     # 2  1


# 命名空间

# 定义
'''
  名称到对象的映射。命名空间是一个字典的实现，键为变量名，值时变量对应的值。各个命名空间是独立没有关系的，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响  
'''
# 分类
'''
    python程序执行期间会有2个或3个活动的命名空间(函数调用时有三个，函数调用结束后2个)。按照变量定义的位置可以划分为以下3类
    
    Local, 局部命名空间，每个函数所拥有的命名空间，记录了函数中定义的所有变量，包括函数的入参，内部定义的局部变量
    Global,全局命名空间,每个模块加载执行时创建，记录了模块中定义的变量，包括模块中定义的函数、类、其他导入的模块、模块级的变量与常量
    Built-in,Python自带的内建命名空间，任何模块均可以访问，放着内置的函数和异常
'''

#  生命周期
'''
    Local(局部命名空间) 在函数调用时才被创建，但函数返回结果或抛出异常时被删除。(每一个递归函数都拥有自己的命名空间)
    Global(全局命名空间) 在模块被加载时创建，通常一直保留直到Python解释器退出。
    Built-in(内建命名空间) 在Python解释器启动是创建，一直保留直到解释器退出
    
    * 各命名空间创建顺序：Python解释器启动->创建内建命名空间->加载模块->创建全局命名空间->函数被调用->创建局部命名空间
    * 各命名空间销毁顺序： 函数调用结束->销毁对应的局部命名空间->python虚拟机(解释器)退出->销毁全局命名空间->销毁内建命名空间
    
    python解释器加载阶段会创建内建命名空间、模块的全局命名空间，局部命名空间是运行阶段函数被调用时动态创建出来，函数调用结束动态销毁的
'''


# 作用域
# 定义    作用域是针对变量而言，指申明的变量在程序里的可应用范围，或者成为变量的可见性

# 分类
'''
    只有函数、类、模块会产生作用域，代码块不会产生作用域。作用域按照变量的定义位置可以划分为4类
    
    Local(函数内部)  局部作用域
    Enclosing (嵌套函数的外层函数内部) 嵌套作用域(闭包)
    Global(模块全局)  全局作用域
    Built-in  (内建) 内建作用域
'''

# 规则
'''
    1 静态作用域规则
    定义： Python中变量的作用域是由他在源代码中的位置决定的(名字的查找过程是动态发生的)
    说明：
    
    2 最内嵌套作用域规则
        定义： 由一个赋值语句引进的名字在这个赋值语句所在的作用域里是可见的(起作用的)，而且在其内部嵌套的每个作用域内也可见，除非他被嵌套于内部的且引用同样名字的赋值语句所遮蔽
        
        说明：
'''

# 命名空间与作用域的关系
'''
    命名空间定义了在某个作用域内变量名和绑定值之间的对应关系，命名空间是键值对的集合，变量名与值是一一对应的关系。作用域定义了命名空间中的变量能够在多大范围内起作用
    
    命名空间在Python解释器中是以字典的形式存在的，是一种可以看得见摸得着的实体存在的。作用域是Python解释器定义的一种规则，该规则确定了运行时变量查找的顺序，是一种行而上的虚的规定
    
'''

# 变量查找法则
'''
    python 解释器动态执行过程中，对遇到的变量进行解释时，是按照一条固定的作用域链查找解释的，又被称为LEGB法则
    Python解释器查找变量时，会按照顺序依次查找局部作用域，嵌套作用域，全局作用域，内建作用域，在任意一个作用域中找到变量则停止查找，所有作用域查找完成没有找到对应的变量，则抛出异常

'''





