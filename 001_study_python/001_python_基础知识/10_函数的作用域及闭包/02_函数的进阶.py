# 函数的进阶

a = 1

def func():
    print(a)
func()


# def func():
#     b = 1
# print(b)

# 命名空间和作用域

    # 内置命名空间  ----  python解释器
        # 就是Python解释器 一启动就可以使用的名称，存储在内置命名空间
        # 内置的名称在启动解释器的时候就被加载进内存
        # print input list..

    # 全局命名空间  ----  我们写下的代码，但不是函数中的代码
        # 是在程序从上到下被执行的过程中依次加载进内存的
        # 放置了我们设置的所有变量名和函数名

    # 局部命名空间  ----  函数
        # 就是函数内部定义的名字
        # 当调用函数的时候，才会产生这个命名空间，随着函数执行的结束而消失


# 在局部 ：可以使用全局、内置命名空间、局部中的名字
# 在全局 ：可以使用内置命名空间、全局中的名字，但是不能使用局部命名空间的名字
# 在内置 ：可以使用内置的名字，不能使用全局的、局部的

# 在正常情况下，直接使用内置的名字
# 当我们在全局定义了和内置名称空间中同名的名字时，会使用全局的名字
# 当自己没有，就找上一级要,上一级也没有就找上上级要,如果自己有，就用自己的，如果内置命名空间都没有，就报错
# 多个函数应该拥有多个独立的局部命名空间，不互相共享

# func() => 函数的内存地址()  函数才会执行

print(id(func))
print(hex(id(func)))
print(func)


# 作用域
# 作用域和命名空间是分不开的，由于有了作用域，后来才有了命名空间去约束作用域

# 作用域有两种
    # 全局作用域  ----  作用在全局  ----  内置和全局命名空间中的名字都属于全局作用域  globals()
    # 局部作用域  ----  作用在局部  ----  函数(局部命名空间中的名字属于局部作用域)    locals()


test = 1
def func():
    # 对于不可变数据类型，在局部可以查看全局作用域中的变量
    # 但是不能直接修改
    # 如果想要修改，需要在程序的一开始添加 global声明
    # 如果在一个局部(函数)内声明了一个global变量，那么这个变量在局部的所有操作将对于全局的变量有效

    # a += 1
    global test
    test = 50

print(test)


test01 = 1
test02 = 2
def func():
    x = 'aaa'
    y = 'bbb'
    print(locals())

func()
print(globals()) # 永远是全局的
print(locals())  # 本地

# globals 永远打印全局的名字
# locals 输出什么，根据locals所在位置

# 尽量不要使用global参数，通过参数和返回值来实现















